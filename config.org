#+TITLE: Emacs Configuration

* General Configuration
#+BEGIN_SRC emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
#+END_SRC
** Personal Information
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Herwig Hoehenberger"
      user-mail-address "herwig.hoehenberger@gmail.com"
      epa-file-encrypt-to user-mail-address)
#+END_SRC
*** University Variables
#+BEGIN_SRC emacs-lisp
(setq herwig/agenda-lv-groups
      ;; Org-Super-Agenda groups for grouping by class
      '((:name "Funktional Analysis" :tag "Funktional_Analysis")
        (:name "Einführing in die Algebra" :tag "Einfd_Algebra")
        (:name "Wahrscheinlichkeitstheorie" :tag "Wahrscheinlichkeitstheorie")
        (:name "Optimierung 1" :tag "Optimierung_1")))
#+END_SRC
** Better Defaults
*** Simple Settings
#+BEGIN_SRC emacs-lisp
(setq-default
 uniquify-buffer-name-style 'forward              ; Uniquify buffer names
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq sentence-end-double-space t                 ; the only correct choice
      auto-save-default t
      default-input-method "german-postfix"       ; for when I need to type ä, ö, ü or ß
      evil-want-fine-undo t                       ; the finer the undo, the better
      inhibit-compacting-font-caches t            ; when there are a lot of glyphs, keep them in memory
      undo-limit 80000000                         ; the more the undo, the better
      +evil-want-o/O-to-continue-comments nil)

(delete-selection-mode 1)                         ; Replace selection when inserting text
(global-subword-mode 1)                           ; Iterate through CamelCase words
#+END_SRC
*** Keybindings
I find ibuffer incredibly useful for buffer management, and closing multiple buffers at once.
#+BEGIN_SRC emacs-lisp
(map!
 :leader
 (:prefix ("b" . "buffer")
  :desc "ibuffer" "i" #'ibuffer))
#+END_SRC
I use ~SPC f s~ a lot to save files, but it's not the most ergonomic for me, using
a Dvorak layout.  So I want to train myself to use ~:w~ instead.
#+BEGIN_SRC emacs-lisp
(map!
 :leader
 (:prefix ("f" . "file")
  "s" nil))
#+END_SRC
*** Git
Use evil-normal-state map in git-timemachine, so that I can move up and down using j & k.
#+BEGIN_SRC emacs-lisp
(after! git-timemachine
  (evil-make-overriding-map git-timemachine-mode-map 'normal)
  (add-hook! git-timemachine-mode-hook #'evil-normalize-keymaps))
#+END_SRC
*** Windows
Split windows to the right and bottom.
#+BEGIN_SRC emacs-lisp
  (setq evil-split-window-below t
        evil-vsplit-window-right t)
#+END_SRC
And then, pull up ivy.
#+BEGIN_SRC emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (+ivy/switch-buffer))
#+END_SRC
Previews are also nice.
#+BEGIN_SRC emacs-lisp
(setq +ivy-buffer-preview t)
#+END_SRC
* UI
** Font
I use a different on my two computers.
TODO set the correct sizes.
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Fira Code" :size (if IS-MAC 14.0 11.0))
      doom-big-font (font-spec :family "Fira Code" :size (if IS-MAC 18.0 14.0))
      doom-variable-pitch-font (font-spec :family "Overpass" :size 14.0)
      zenburn-use-variable-pitch t)
#+END_SRC
** Theme
This is subject to frequent change.
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'zenburn)
#+END_SRC
** Misc
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative
      evil-echo-state nil                      ; I find it distracting; and I can tell the state from the cursor
      frame-title-format "%b"
      mode-line-default-help-echo nil
      scroll-bar-mode nil
      show-help-function nil
      show-paren-delay 0)
#+END_SRC
* Package Configuration
** Calc
Ah, Emacs Calc, poor man's mathematica.
#+BEGIN_SRC emacs-lisp
(after!
    (setq calc-angle-mode 'rad
          calc-algebraic-mode t
          calc-symbolic-mode t)
    (evil-set-initial-state 'calc-mode 'emacs))
#+END_SRC
** Company
I disable autocompletion by default, and only use it on demand.
#+BEGIN_SRC emacs-lisp
(after! company
  (setq company-idle-delay nil))
#+END_SRC
** Direnv
I disable the frequent, verbose summary messages.
#+BEGIN_SRC emacs-lisp
(after! direnv
  (setq direnv-always-show-summary nil))
#+END_SRC
** Hercules
#+BEGIN_SRC emacs-lisp
(use-package! hercules
  :config
  (hercules-def
   :show-funs #'macrostep-expand
   :hide-funs #'macrostep-collapse-all
   :keymap 'macrostep-keymap))
#+END_SRC
** Which-Key
#+BEGIN_SRC emacs-lisp
(after! which-key
  (setq which-key-idle-delay 0.5)
  (setq which-key-allow-multiple-replacements t)
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))))
#+END_SRC
* Language Configuration
** Haskell
#+BEGIN_SRC emacs-lisp
(after! haskell
  (setq haskell-interactive-popup-errors nil))
#+END_SRC
** LaTeX
*** Auto LaTeX Snippet
#+BEGIN_SRC emacs-lisp
(use-package! auto-latex-snippets
  :hook (LaTeX-mode . auto-latex-snippets-mode)
  :config
  (add-hook 'als-post-snippet-expand-hook #'+latex-fold-last-macro-a))
#+END_SRC
*** Evil-Tex
#+BEGIN_SRC emacs-lisp
(use-package! evil-tex
  :hook (LaTeX-mode . evil-tex-mode))
#+END_SRC
*** Visuals
#+BEGIN_SRC emacs-lisp
(add-hook! LaTeX-mode #'mixed-pitch-mode)
#+END_SRC
** Python
I much prefer ipython to the regular python shell.
#+BEGIN_SRC emacs-lisp
(after! python
  (setq python-shell-interpreter "ipython"))
#+END_SRC
** Org
*** General
#+BEGIN_SRC emacs-lisp
(setq
 org-directory (expand-file-name "Org" (getenv "HOME"))
 org-archive-location (expand-file-name ".archive/%s::" org-directory)
 org-blank-before-new-entry '((heading . nil) (plain-list-item . nil))
 org-catch-invisible-edits 'smart
 org-export-in-background t
 org-list-allow-alphabetical t)

(after! org
  (setq org-refile-targets '((nil :maxlevel . 7) (org-agenda-files :maxlevel . 7))))

(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC

I use org-mode to track my habits, besides other things.
#+BEGIN_SRC emacs-lisp
(after! org
  (add-to-list 'org-modules 'org-habit t))
#+END_SRC

I unset these variables because I currently don't use the files, and don't want
them to be open all the time.
#+BEGIN_SRC emacs-lisp
(after! org
    (setq +org-capture-projects-file nil
        +org-capture-changelog-file nil
        +org-capture-journal-file nil))
#+END_SRC
**** Keybindings
#+BEGIN_SRC emacs-lisp
(after! org
  (map!
    (:map org-mode-map
     :localleader
       "e" nil
       "i" nil))
  (map!
    (:map org-mode-map
     :localleader
        (:prefix ("e" . "export")
          :desc "org-export-dispatch" "d" #'org-export-dispatch)

        (:prefix ("i" . "insert")
          :desc "org-insert-heading-after-current" "h" #'org-insert-heading-after-current
          :desc "org-insert-heading" "H" #'org-insert-heading
          :desc "org-insert-subheading" "s" #'org-insert-subheading))))
#+END_SRC

Disable ~org-super-agenda-header-map~ because I want to be able to use ~j, k~ to
move up and down on /every/ line in ~org-agenda~.
#+BEGIN_SRC emacs-lisp
(after! org-super-agenda
    (setq org-super-agenda-header-map (make-sparse-keymap)))
#+END_SRC
*** Agenda
#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))
(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-block-separator nil
      org-agenda-compact-blocks t
      org-agenda-include-deadlines t
      org-agenda-start-day "-1d"
      org-agenda-show-future-repeats 'next
      org-agenda-todo-ignore-scheduled t
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-scheduled-if-done t)
#+END_SRC
Put ~org-agenda~ on a more convenient key because I use it a lot.
#+BEGIN_SRC emacs-lisp
(map!
  :leader
  :desc "Agenda" "a" #'org-agenda)
#+END_SRC
I use ~org-agenda-custom-commands~ a lot, so that I only see the tasks I want to
see at any moment.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("f" "Forecast"
         ((agenda "" ((org-agenda-start-day "today")
                      (org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Habits"
                          :habit t
                          :order 2)
                         (:name "Overdue"
                          :scheduled past
                          :deadline past)
                         (:name "Forecast"
                          :time-grid t
                          :date today
                          :scheduled today
                          :deadline today)
                         (:name "Due Soon"
                          :deadline future
                          :discard (:anything t)
                          :order 3)))))))
        ("p" . "Personal")
         ("pt" "Todo"
          ;; TODO customize groups
            ((org-ql-block '(and (category "Personal")
                                 (not (todo "DONE" "[X]")))
                            ((org-super-agenda-groups
                              '((:auto-parent t)))))))
         ("u" . "University")
          ("uh" "Hold/Wait"
           ((org-ql-block '(and (category "University")
                                (todo "WAIT" "HOLD"))
                           ((org-super-agenda-groups `(,@herwig/agenda-lv-groups))))))
          ("up" "Problems"
           ((org-ql-block '(and (category "University")
                                (tags "Assignment")
                                (not (or (todo "DONE" "[X]"))))
                           ((org-super-agenda-groups `(,@herwig/agenda-lv-groups))
                            (org-agenda-dim-blocked-tasks 'invisible)
                            (org-ql-block-header "Problems")))))
          ("ut" "Todo"
           ((org-ql-block '(and (category "University")
                                (not (or (tags "Assignment")
                                         (todo "DONE" "PROJ" "WAIT" "HOLD" "[X]" "KILL"))))
                           ((org-super-agenda-groups
                             `((:deadline t)
                               ,@herwig/agenda-lv-groups))))))
          ("us" "Shut Down"
           ((agenda "" ((org-agenda-start-day "today")
                        (org-agenda-span 2)
                        (org-super-agenda-groups
                         '((:name "Overdue"
                            :discard (:habit t)
                            :scheduled past
                            :deadline past)
                           (:name "Agenda"
                            :discard (:and (:deadline t
                                            :scheduled t))
                            :anything t)))))
            (org-ql-block '(and (category "University")
                                (not (or (scheduled :from tomorrow)
                                         (todo "DONE" "PROJ" "WAIT" "HOLD" "[X]" "KILL"))))
                          ((org-super-agenda-groups
                            `(,@herwig/agenda-lv-groups
                              (:discard (:not (:todo t)))))
                           (org-agenda-dim-blocked-tasks 'invisible)
                           (org-ql-block-header "Available University Tasks")))))))
#+END_SRC
**** Calendar
#+BEGIN_SRC emacs-lisp
(use-package! org-gcal
  :defer 1
  :config
  (setq org-gcal-directory (expand-file-name ".gcal" org-directory))
  (pushnew org-gcal-directory org-agenda-files )
  (load-library (expand-file-name "gcal-credentials.el.gpg" (getenv "DOOMDIR"))))
#+END_SRC
*** Anki
#+BEGIN_SRC emacs-lisp
(use-package anki-editor
  :after org
  :init
  (setq-default anki-editor-use-math-jax t))
#+END_SRC
*** Capture
The following code was taken verbatim from *@tecosaurs* config.  I really like
the way it makes ~org-capture~ look, but my elisp-foo is not nearly good enough
to make something like this on my own.
#+BEGIN_SRC emacs-lisp
(use-package! doct
  :commands (doct))

(map!
  :leader
  :desc "Org Capture" "SPC" #'org-capture
  "X" nil)

(after! (org-capture org-gcal)
  (defun org-capture-select-template-prettier (&optional keys)
    "Select a capture template, in a prettier way than default
  Lisp programs can force the template by setting KEYS to a string."
    (let ((org-capture-templates
           (or (org-contextualize-keys
                (org-capture-upgrade-templates org-capture-templates)
                org-capture-templates-contexts)
               '(("t" "Task" entry (file+headline "" "Tasks")
                  "* TODO %?\n  %u\n  %a")))))
      (if keys
          (or (assoc keys org-capture-templates)
              (error "No capture template referred to by \"%s\" keys" keys))
          (org-mks org-capture-templates
                  "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
                  "Template key: "
                  `(("q" ,(concat
                           (all-the-icons-octicon "stop"
                                                  :face 'all-the-icons-red
                                                  :v-adjust 0.01)
                           "\tAbort")))))))
  (advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

  (defun org-mks-pretty (table title &optional prompt specials)
    "Select a member of an alist with multiple keys. Prettified.

  TABLE is the alist which should contain entries where the car is a string.
  There should be two types of entries.

  1. prefix descriptions like (\"a\" \"Description\")
     This indicates that `a' is a prefix key for multi-letter selection, and
     that there are entries following with keys like \"ab\", \"ax\"…

  2. Select-able members must have more than two elements, with the first
     being the string of keys that lead to selecting it, and the second a
     short description string of the item.

  The command will then make a temporary buffer listing all entries
  that can be selected with a single key, and all the single key
  prefixes.  When you press the key for a single-letter entry, it is selected.
  When you press a prefix key, the commands (and maybe further prefixes)
  under this key will be shown and offered for selection.

  TITLE will be placed over the selection in the temporary buffer,
  PROMPT will be used when prompting for a key.  SPECIALS is an
  alist with (\"key\" \"description\") entries.  When one of these
  is selected, only the bare key is returned."
    (save-window-excursion
      (let ((inhibit-quit t)
            (buffer (org-switch-to-buffer-other-window "*Org Select*"))
            (prompt (or prompt "Select: "))
            case-fold-search
            current)
        (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
      ;; Populate allowed keys and descriptions keys
      ;; available with CURRENT selector.
            (let ((re (format "\\`%s\\(.\\)\\'"
                      (if current (regexp-quote current) "")))
                  (prefix (if current (concat current " ") "")))
              (dolist (entry table)
                (pcase entry
                  ;; Description.
                  (`(,(and key (pred (string-match re))) ,desc)
                   (let ((k (match-string 1 key)))
                     (push k des-keys)
                      ;; Keys ending in tab, space or RET are equivalent.
                     (if (member k tab-alternatives)
                         (push "\t" allowed-keys)
                         (push k allowed-keys))
                      (insert
                       (propertize prefix 'face 'font-lock-comment-face)
                       (propertize k 'face 'bold)
                       (propertize "›" 'face 'font-lock-comment-face)
                       "  " desc "…" "\n")))
                      ;; Usable entry.
                  (`(,(and key (pred (string-match re))) ,desc . ,_)
                   (let ((k (match-string 1 key)))
                     (insert (propertize prefix 'face 'font-lock-comment-face)
                             (propertize k 'face 'bold) "   " desc "\n")
                     (push k allowed-keys)))
                  (_ nil))))
            ;; Insert special entries, if any.
            (when specials
              (insert "─────────────────────────\n")
              (pcase-dolist (`(,key ,description) specials)
                (insert (format "%s   %s\n"
                                (propertize key 'face '(bold all-the-icons-red))
                                description))
                (push key allowed-keys)))
            ;; Display UI and let user select an entry or
            ;; a sub-level prefix.
            (goto-char (point-min))
            (unless (pos-visible-in-window-p (point-max))
              (org-fit-window-to-buffer))
            (let ((pressed (org--mks-read-key allowed-keys prompt)))
              (setq current (concat current pressed))
              (cond
                ((equal pressed "\C-g") (user-error "Abort"))
                ;; Selection is a prefix: open a new menu.
                ((member pressed des-keys))
                ;; Selection matches an association: return it.
                ((let ((entry (assoc current table)))
                   (and entry (throw 'exit entry))))
                ;; Selection matches a special entry: return the
                ;; selection prefix.
                ((assoc current specials) (throw 'exit current))
                (t (error "No entry available")))))))
          (when buffer (kill-buffer buffer))))))
  (advice-add 'org-mks :override #'org-mks-pretty)

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates
            (mapcar (lambda (template)
                      (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                  (spec (plist-get (plist-get props :doct) :icon)))
                        (setf (nth 1 template)
                              (concat (+doct-icon-declaration-to-icon spec)
                                      "\t"
                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (add-transient-hook! 'org-capture-select-template
    (setq org-capture-templates
        (doct
        `(("Todo" :keys "t"
            :file +org-capture-todo-file
            :icon ("inbox" :set "octicon" :color "purple")
            :prepend t
            :headline "Inbox"
            :template ("* %{todo-state} %?"
                       "%i %a")
            :children (("TODO" :keys "t"
                        :icon ("check_box" :set "material" :color "purple")
                        :todo-state "TODO")
                        ("[ ]" :keys "T"
                        :todo-state "[ ]")))
            ("Calendar Event" :keys "a"
            :file ,(alist-get org-gcal-changes-id org-gcal-file-alist)
            :icon ("event_note" :set "material" :color "blue")
            :hook org-gcal-post-at-point
            :calendar-id ,org-gcal-changes-id
            :template ("* %^{Description}"
                        ":PROPERTIES:"
                        ":calendar-id: %{calendar-id}"
                        ":END:"
                        ":org-gcal:"
                        "%^{Start}T--%^{End}T"
                        ":END:"))
            ("University" :keys "u"
            :file +org-capture-todo-file
            :icon ("graduation-cap" :set "faicon" :color "yellow")
            :prepend t
            :headline "Inbox"
            :children (("Übungszettel"
                        :keys "u"
                        :icon ("library_books" :set "material" :color "orange")
                        :template ("* TODO %^{No}. Übungszettel :Assignment:"
                                    "DEADLINE: %^{Due date}T"
                                    ":PROPERTIES:"
                                    ":ORDERED:  t"
                                    ":END:"
                                    "** TODO Download PDF"
                                    "** TODO Solve Problems"
                                    "*** [ ] %?"
                                    "** TODO Upload Solutions"))
                        ("Exam"
                        :keys "p"
                        :icon ("local_library" :set "material" :color "green")
                        :template ("* TODO VO Prüfung machen"
                                    ":PROPERTIES:"
                                    ":ORDERED:  t"
                                    ":END:"
                                    "** TODO Prepare"
                                    ":PROPERTIES:"
                                    ":ORDERED:  nil"
                                    ":END:"
                                    "*** TODO Termin ausmachen :email:"
                                    "*** TODO [#D] Karteikarten schreiben"
                                    "** TODO Lernen")))))))))
#+END_SRC

*** Crypt
#+BEGIN_SRC emacs-lisp
(after! org
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt"))
        org-crypt-key "F1653669C24076F7"))
#+END_SRC
*** Journal
I'm a big fan of the idea to up our calendar year by 10000, from [[https://www.youtube.com/watch?v=czgOWmtGVGs][this video]].

Setting the ~time-prefix~ to ~**~, is a bit of a hack to start a new journal entry with a subheading.
#+BEGIN_SRC emacs-lisp
(setq org-journal-dir (expand-file-name "Journal" org-directory))
(after! org-journal
  (setq org-journal-file-format "1%Y/%m %B.org" ;; e.g. 12019/04 April.org
        org-journal-encrypt-journal t
        org-journal-file-type 'monthly
        org-journal-date-prefix "* "
        org-journal-date-format "1%F %a" ;; e.g. 12019-04-01 Fri
        ;; see here for formatting symbols: https://www.gnu.org/software/emacs/manual/html_node/elisp/Time-Parsing.html
        org-journal-time-prefix "** "
        org-journal-time-format "")
  (defun herwig/setup-entry ()
    "Function to run when entering a new journal entry.

Sets up everything the way I want it to be when journaling."
    (progn
      (toggl-start-time-entry "Journal" (toggl-get-pid "Solitude") "Journal Timer Started!")
      (doom/window-maximize-buffer)
      (evil-scroll-line-to-top (line-number-at-pos))
      (evil-scroll-line-up 2)
      (writeroom-mode)
      (turn-on-flyspell)))
  (add-hook! org-journal-after-entry-create #'herwig/setup-entry))
#+END_SRC

Also bind journaling to a key.
#+BEGIN_SRC emacs-lisp
(map!
 :leader
 (:prefix ("n" . "notes")
  :desc "Org Journal" "j" #'org-journal-new-entry))
#+END_SRC
*** Roam
I use a shameless X-Men reference for the name of my second brain.
#+BEGIN_SRC emacs-lisp
(setq org-roam-directory (expand-file-name "Cerebro" org-directory))
#+END_SRC
*** Toggl
Time tracking is one thing I don't use org-mode for (yet).  Having it easily
available from my phone is just too convenient, but it's nice to be able to
start it from Emacs from time to time, especially automatically, when journaling.
#+BEGIN_SRC emacs-lisp
(use-package! org-toggl
  :defer 1
  :config
  (load-library (expand-file-name "toggl-auth-token.el.gpg" (getenv "DOOMDIR")))
  (setq org-toggl-inherit-toggl-properties t)
  (toggl-get-projects))
#+END_SRC
*** Visuals
#+BEGIN_SRC emacs-lisp
(add-hook! org-mode #'(+org-pretty-mode mixed-pitch-mode))
(add-hook! org-mode (display-line-numbers-mode -1))
(add-hook! org-agenda-mode #'+org-pretty-mode)
#+END_SRC
**** Fonts
Make headings bigger.
#+BEGIN_SRC emacs-lisp
(setq zenburn-scale-org-headlines t)
#+END_SRC
**** Symbols
I took these symbols from the amazing [[https://tecosaur.github.io/emacs-config/config.html][doom configuration]] of *@tecosaur* and stole
this ellipsis and the bullets from [[https://github.com/hlissner/doom-emacs-private][Henrik Lissner]].  Personally, I really like them.
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-superstar-headline-bullets-list '("☰" "☱" "☲" "☳" "☴" "☵" "☶" "☷")
        org-super-star-prettify-item-bullets t)
  (setq org-ellipsis " ▼ "
        org-priority-highest ?A
        org-priority-lowest ?E
        org-priority-faces '((?A . 'all-the-icons-red)
                             (?B . 'all-the-icons-orange)
                             (?C . 'all-the-icons-yellow)
                             (?D . 'all-the-icons-green)
                             (?E . 'all-the-icons-blue))))
#+END_SRC

Use Unicode characters for check boxes and some other commands.
#+BEGIN_SRC emacs-lisp
(after! org
  (appendq! +pretty-code-symbols
            `(:checkbox      "☐"
              :pending       "◼"
              :checkedbox    "☑"
              :list_property "∷"
              :results       "🠶"
              :property      "☸"
              :properties    "⚙"
              :end           "∎"
              :options       "⌥"
              :title         "𝙏"
              :author        "𝘼"
              :date          "𝘿"
              :latex_header  "⇥"
              :latex_class   "🄲"
              :begin_quote   "❮"
              :end_quote     "❯"
              :begin_export  "⯮"
              :end_export    "⯬"
              :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
              :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
              :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
              :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
              :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)
              :em_dash       "—"))
  (set-pretty-symbols! 'org-mode
    :merge t
    :checkbox      "[ ]"
    :pending       "[-]"
    :checkedbox    "[X]"
    :list_property "::"
    :results       "#+RESULTS:"
    :property      "#+PROPERTY:"
    :properties    ":PROPERTIES:"
    :end           ":END:"
    :options       "#+OPTIONS:"
    :title         "#+TITLE:"
    :author        "#+AUTHOR:"
    :date          "#+DATE:"
    :latex_class   "#+LATEX_CLASS:"
    :latex_header  "#+LATEX_HEADER:"
    :begin_quote   "#+BEGIN_QUOTE"
    :end_quote     "#+END_QUOTE"
    :begin_export  "#+BEGIN_EXPORT"
    :end_export    "#+END_EXPORT"
    :priority_a    "[#A]"
    :priority_b    "[#B]"
    :priority_c    "[#C]"
    :priority_d    "[#D]"
    :priority_e    "[#E]"
    :em_dash       "---"))
#+END_SRC
** Scheme
Currently, I'm only using Scheme for SICP, for which I use the MIT Scheme implementation.
#+BEGIN_SRC emacs-lisp
(after! geiser
  (setq geiser-active-implementations '(mit)
        geiser-default-implementation 'mit))
#+END_SRC
